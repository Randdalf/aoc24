import aoc
import math

xform_cw = [1, 2, 3, 0]
xform_ccw = [3, 0, 1, 2]

fn xform_east(pos):
    return (pos[0] + 1, pos[1])

fn xform_south(pos):
    return (pos[0], pos[1] + 1)

fn xform_west(pos):
    return (pos[0] - 1, pos[1])

fn xform_north(pos):
    return (pos[0], pos[1] - 1)

move_xforms = [xform_east, xform_south, xform_west, xform_north]

class Maze:
    init(input):
        rows = input.split("\r\n")
        self.walls = {}
        for y in 0...rows.num():
            row = rows[y]
            for x in 0...row.len():
                tile = row[x]
                if tile == "#":
                    self.walls.add((x, y), nil)
                elif tile == "E":
                    self.end = (x, y)
                elif tile == "S":
                    self.start = (x, y)

class Node:
    init(maze, pos, dir):
        self.maze = maze
        self.pos = pos
        self.dir = dir

    fn get_neighbors():
        neighbors = []
        neighbors.add(Node(self.maze, self.pos, xform_cw[self.dir]))
        neighbors.add(Node(self.maze, self.pos, xform_ccw[self.dir]))
        adj = move_xforms[self.dir](self.pos)
        if not self.maze.walls.contains(adj):
            neighbors.add(Node(self.maze, move_xforms[self.dir](self.pos), self.dir))
        return neighbors

    fn dist(neighbor):
        if self.dir != neighbor.dir:
            return 1000
        else:
            return 1

    fn key():
        # Instances aren't hashable (yet).
        return (self.pos, self.dir)

class PriorityQueue:
    init():
        self.entries = []

    fn push(node, dist):
        fn parent(i):
            return math.trunc((i - 1) / 2)
        i = self.entries.num()
        j = parent(i)
        self.entries.add(nil)
        while i > 0 and self.entries[j][1] > dist:
            self.entries[i] = self.entries[j]
            i = j
            j = parent(i)
        self.entries[i] = (node, dist)

    fn pop():
        if self.entries.num() == 1:
            return self.entries.pop()[0]
        node = self.entries[0][0]
        self.entries[0] = self.entries.pop()
        i = 0
        while true:
            min = i
            left = 2 * i + 1
            if left < self.entries.num() and self.entries[left][1] < self.entries[min][1]:
                min = left
            right = left + 1
            if right < self.entries.num() and self.entries[right][1] < self.entries[min][1]:
                min = right
            if i == min:
                break
            temp = self.entries[min]
            self.entries[min] = self.entries[i]
            self.entries[i] = temp
            i = min
        return node

    fn num():
        return self.entries.num()

fn dijkstra(src, goal):
    q = PriorityQueue()
    dist = {}

    dist[src.key()] = 0
    q.push(src, 0)

    while q.num() > 0:
        current = q.pop()
        current_dist = dist[current.key()]
        if goal(current):
            return current_dist
        for neighbor in current.get_neighbors():
            alt = current_dist + current.dist(neighbor)
            neighbor_key = neighbor.key()
            if not dist.contains(neighbor_key) or alt < dist[neighbor_key]:
                dist[neighbor_key] = alt
                q.push(neighbor, alt)

export fn part1(input):
    maze = Maze(input)
    src = Node(maze, maze.start, 0)
    fn goal(node):
        return node.pos == maze.end
    return dijkstra(src, goal)

class BFSResult:
    init(dist, prev):
        self.dist = dist
        self.prev = prev

fn bfs(src):
    q = PriorityQueue()
    dist = {}
    prev = {}

    dist[src.key()] = 0
    q.push(src, 0)

    while q.num() > 0:
        current = q.pop()
        current_key = current.key()
        current_dist = dist[current.key()]
        for neighbor in current.get_neighbors():
            alt = current_dist + current.dist(neighbor)
            neighbor_key = neighbor.key()
            if not dist.contains(neighbor_key) or alt < dist[neighbor_key]:
                dist[neighbor_key] = alt
                prev[neighbor_key] = [current_key]
                q.push(neighbor, alt)
            elif alt == dist[neighbor_key]:
                prev[neighbor_key].add(current_key)

    return BFSResult(dist, prev)

export fn part2(input):
    maze = Maze(input)

    # Find the shortest distance from every node to the start.
    src = Node(maze, maze.start, 0)
    result = bfs(src)

    # Determine which of the end nodes has the shortest path to the start.
    best_dist = nil
    best_end_key = nil
    for dir in 0...4:
        end_key = (maze.end, dir)
        if not result.prev.contains(end_key):
            continue
        end_dist = result.dist[end_key]
        if best_dist == nil or end_dist < best_dist:
            best_dist = end_dist
            best_end_key = end_key
            
    # Work backwards along the paths found, using depth-first search.
    tiles = {}
    stack = [best_end_key]

    while stack.num() > 0:
        node = stack.pop()
        tiles.add(node[0], nil)
        if not result.prev.contains(node):
            continue
        for prev in result.prev[node]:
            stack.add(prev)
            
    return tiles.num()

if is_main():
    aoc.solve(16, part1, part2)
